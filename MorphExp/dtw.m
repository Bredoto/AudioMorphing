function [error,path1,path2] = dtw(s1, s2)% [error,path1,path2] = dtw(s1, s2)% Dynamic Time Warping search... by Malcolm Slaney% After this routine%	s1 approximately = s2(path1)%	s2 approximately = s1(path2)% and error is a scalar with the lowest energy found.% Both s1 and s2 are warped with respect to their columns%  (each column stays the same, but shifts in position)%% (c) Interval Research, Inc., May 31, 1995% Thanks to Tony Robinson (Cambridge Univ.) for the structure% of this routine.  His algorithm was kindly posted to % comp.speech on 29 Dec. 1994.[d1 l1] = size(s1);[d2 l2] = size(s2);if (d1 ~= d2)	fprintf('DTW Error: Depth of two data arrays is not equal.\n')	returnend% Now figure out all the relative distances all at once.  We'll% never use the outside corners of this array, but it's easier% to calculate all at once.ldist=zeros(l1, l2);for i=1:l1	for j=1:l2		ldist(i,j) = sum((s1(:,i)-s2(:,j)).^2);	endend% We're only going to allow slopes of 2,1,.5.  topPath=1;midPath=2;botPath=3;% We'll fill the global distance array with infinities.gdist=ones(l1, l2)*inf;path=ones(l1, l2)*nan;% The first two directions are fixed.  They have to be the % middle path.gdist(1,1) = ldist(1,1);path(1,1) = midPath;gdist(2,2) = gdist(1,1) + ldist(2,2);path(2,2) = midPath;for i=3:l1	for j=3:l2		top = gdist(i-2,j-1) + ldist(i-1,j) + ldist(i,j);    	mid = gdist(i-1,j-1) + ldist(i,j);    	bot = gdist(i-1,j-2) + ldist(i,j-1) + ldist(i,j);		[gdist(i,j) path(i,j)]= min([top mid bot]);	endenderror = gdist(l1,l2);% Now backtrack through the array looking for the path that got% us the minimum distance.  Luckily we left a string of % directions that we can use to find our way back to the origin.p1 = l1;p2 = l2;while (p1 > 0 & p2 > 0)	path1(p1) = p2;	path2(p2) = p1;	direct = path(p1,p2);	if (direct == topPath)		p1 = p1 - 1;		path1(p1) = p2;		path2(p2) = p1;	elseif (direct == botPath)		p2 = p2 - 1;		path1(p1) = p2;		path2(p2) = p1;	end	p1 = p1 - 1;	p2 = p2 - 1;end% Now (optionally) plot the result.  if 0	m = max(l1, l2);		subplot(3,1,1);	if (d1 ~= 1)		imagesc(s1);		axis([1 m 1 d1]);	else		plot(s1)		axis([1 m min(s1) max(s1)]);	end	title('Signal 1');	if 0		s15 = zeros(size(s1));		for i=1:l1			s15(:,i) = s2(:,path1(i));		end		subplot(3,1,2);		if (d1 ~= 1)			imagesc(s15);			axis([1 m 1 d1]);		else			plot(s15);			axis([1 m min(s15) max(s15)]);		end		title('Signal 2 warped to be like Signal 1');	else		s15 = zeros(size(s2));		for i=1:l1			s15(:,i) = s1(:,path2(i));		end		subplot(3,1,2);		if (d1 ~= 1)			imagesc(s15);			axis([1 m 1 d1]);		else			plot(s15);			axis([1 m min(s15) max(s15)]);		end		title('Signal 1 warped to be like Signal 2');	end		subplot(3,1,3);	if (d1 ~= 1)		imagesc(s2);		axis([1 m 1 d1]);	else		plot(s2);		axis([1 m min(s2) max(s2)]);	end	title('Signal 2');end% The following is useful test code... generate a known warping % signal, generate two arrays of sort of random data, and then% use d1 and d2 as dtw input.if 0	warp = [ones(1,4) ones(1,4)*2 ones(1,4) ones(1,4)*.5];	warp = cumsum(warp);		d1 = rand(2,max(warp));	d1(1,:) = filter([1 1 1 1],[1],d1(1,:)')';	d1(2,:) = filter([1 1 1 1],[1],d1(2,:)')';		d2 = d1(:,warp);end if 0	warp = [ones(1,4) ones(1,4)*2 ones(1,4) ones(1,4)*.5];	warp = cumsum(warp);		d1 = rand(1,max(warp));	d1(1,:) = filter([1 1 1 1],[1],d1(1,:)')';	d2 = d1(:,warp);end 